---
title: "Guanyingdong Stone Artefact Assemblage Report"
author: "HY and BM"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
   bookdown::word_document2:
    fig_caption: yes
    reference_docx: templates/template.docx
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      eval = FALSE)

```

```{r eval=TRUE, echo=FALSE}
# read in the data
library(plyr)
library(dplyr)
library(knitr)
library(readxl)
library(ggplot2)
library(tidyr)
library(purrr)
library(GGally)
library(ggforce)
# set working directory to source
# original filename: artefacts (自动保存的).xls 
file_name <- here::here("analysis/data/data_raw/artefacts (xxx).xls") 
quiet_read <- purrr::quietly(readxl::read_excel)
flakes <- quiet_read(file_name, sheet = "flake basics")$result
cores <- quiet_read(file_name, sheet = "core basics")$result
debris <- quiet_read(file_name, sheet = "chunk&debris")$result
retouch <- quiet_read(file_name, sheet = "retouch")$result
scar_direction <- quiet_read(file_name, sheet = "scar direction ")$result
edge_angle <- quiet_read(file_name, sheet = "edge angle")$result
core_scars_length <- quiet_read(file_name, sheet = "core flake scars")$result
names(core_scars_length) <- make.names(names(core_scars_length))
```

```{r eval=TRUE, echo=FALSE}
# are the artefact numbers really unique?
# sum(duplicated(flakes$number))

# change the name of flakes by adding "f_"
flakes$number <- paste0( "f_", flakes$number)

# extract duplicated flakes 
flakes_duplicated <- flakes[ duplicated(flakes$number), ]

# remove from original data
flakes <- flakes[!duplicated(flakes$number), ]

# update the artefact ID so it's not duplicate
flakes_duplicated$number <- paste0(flakes_duplicated$number, "a")

# put back into original data 
flakes <- rbind(flakes, flakes_duplicated)

flakes$initiation <- ifelse(flakes$initiation %in% c("hert", "h"), "hertzian",
                            ifelse(flakes$initiation == "bend", "bending",
                                   ifelse(flakes$initiation %in% c("wedging", "wed"), "wedge",
                                          ifelse(flakes$initiation %in% c("miss", "mis"),
                                                 "missing", flakes$initiation))))


flakes$platform <- ifelse(flakes$platform == "plane", "plain",
                          ifelse(flakes$platform %in% c("miss", "mis", "42.000000", "0.000000", "overh"), "missing",
                                 ifelse(flakes$platform == "facted", "faceted",flakes$platform)))

flakes$termination <- ifelse(flakes$termination == "f", "feather",
                             ifelse(flakes$termination == "br", "break",
                                    ifelse(flakes$termination %in% c("brpt", "brput"), "abrupt",
                                           ifelse(flakes$termination == "plung", "plunge",
                                                  ifelse(flakes$termination == "st", "step",
                                                         ifelse(flakes$termination %in% c("m", "miss", "na", "over"), "missing",flakes$termination))))))


flakes$`Width at 25% max dim` <- ifelse(flakes$`Width at 25% max dim` == 332.7, 33.2,
                                        ifelse(flakes$`Width at 25% max dim` == 668, 66.8,flakes$`Width at 25% max dim`))

# do the same for the retouch...

# are the artefact numbers really unique?
#sum(duplicated(retouch$number))

retouch$number <- paste0( "f_", retouch$number)

# extract duplicated retouch 
retouch_duplicated <- retouch[ duplicated(retouch$number), ]

# remove from original data
retouch <- retouch[!duplicated(retouch$number), ]

# update the artefact ID so it's not duplicate
retouch_duplicated$number <- paste0(retouch_duplicated$number, "a")

# put back into original data 
retouch <- rbind(retouch, retouch_duplicated)


# do the same for the debris...

# are the artefact numbers really unique?
# sum(duplicated(debris$number))

debris$number <- paste0( "d_", debris$number)

# extract duplicated retouch 
debris_duplicated <- debris[ duplicated(debris$number), ]

# remove from original data
debris <- debris[!duplicated(debris$number), ]

# update the artefact ID so it's not duplicate
debris_duplicated$number <- paste0(debris_duplicated$number, "a")

# put back into original data 
debris <- rbind(debris, debris_duplicated)


# do the same for the core...

# are the artefact numbers really unique?
# sum(duplicated(cores$number))

cores$number <- paste0( "c_", cores$number)

# extract duplicated retouch 
cores_duplicated <- cores[ duplicated(cores$number), ]

# remove from original data
cores <- cores[!duplicated(cores$number), ]

# update the artefact ID so it's not duplicate
# cores_duplicated$number <- paste0(cores_duplicated$number, "a")

# put back into original data 
cores <- rbind(cores, cores_duplicated)



############
# basic details of the dataset
artefact_ids <- list(flake_ids = flakes$number,
                     core_ids = cores$number,
                     debris_ids = debris$number,
                     retouch_ids = retouch$number)



# how many unique artefacts?
totals_of_each_type <- lapply(artefact_ids, function(i) length(unique(i)))

#count_unique_artefacts <- sum(unlist(totals_of_each_type))

count_unique_artefacts <- length(unique(unlist(artefact_ids[1:3])))

# debris pieces that are  retouch pieces
### debris_with_retouch <- intersect(artefact_ids$retouch_ids, artefact_ids$debris_ids)

### proportion_debris_retouched <- length(debris_with_retouch) / count_unique_artefacts 

# flakes that are retouched pieces
flake_with_retouch <- intersect(artefact_ids$retouch_ids, artefact_ids$flake_ids)

proportion_flake_retouched <- length(flake_with_retouch) / count_unique_artefacts 


# proportion of each type
type_table <- data.frame(type = names(as.data.frame(totals_of_each_type)),
                         count = as.numeric(as.data.frame(totals_of_each_type)),
                         proportion = round(as.numeric(as.data.frame(totals_of_each_type)/count_unique_artefacts),3))

# add total row at the bottom
type_table$type <- as.character(type_table$type)

type_table <- rbind(type_table, c("total", count_unique_artefacts, round(sum(type_table$proportion),2)))
# total number of artefacts
total_number_of_artefacts <- as.numeric(type_table$count[type_table$type == "total"])

# print pretty table                         
# kable(type_table)
```


# Introduction 

The Guanyindong site, located in  Guanyindong village, Qianxi County of Guizhou Province (26°51′26″N, 105°58′7″E) at an elevation of 1464 m a.s.l., is a limestone cave site extending from east to west it was discovered by a team organized by the institute of Vertebrate Paleontology and Paleoanthropolgy (IVPP), Chinese Academy of Sciences in 1964. Several excavations were conducted in 1965, 1972 and 1973, yeilding   A total of `r type_table$count[2]` cores, `r type_table$count[1]` flakes, `r type_table$count[4]` retouched pieces and `r type_table$count[3]` pieces of debris were identified. 


## Raw materials

```{r eval = TRUE, rawmaterials}
flake_raw_material <- table(flakes$material)

#' Data frame of counts, frequences and proportion of values in a vector
#' 
#' @param x a vector

tbl_of_counts_and_props <- function(x){
  tbl <- table(x)
  res <- data.frame(tbl, 
                    round(prop.table(tbl) * 100, 2))
  colnames(res) <- c('Name', 'Count', 'Percentage', 'Proportion')
  res
}

raw_material_tbl <- tbl_of_counts_and_props(flakes$material)

# raw materials of retouch pieces
retouch_flake_details <- 
flakes %>% 
left_join(retouch) %>% 
filter(!is.na(`number of layers`))
# how many chert flakes?

chert_flake<- sum(grepl("chert", flakes$material))


chert_ret<- flakes %>% 
  filter(grepl("chert", material)) %>%
  filter(grepl("ret", type)) %>% 
  nrow()
percentage_of_chert_tools <-round(chert_ret/chert_flake * 100, 2)

# how many retouched pieces were limestone

limestone_ret<- flakes %>% 
  filter(grepl("limestone", material)) %>%
  filter(grepl("ret", type)) %>% 
  nrow()

```

Previous research reported that the stone artefacts are preliminarily made of siliceous limestone, In my observation,the majority of siliceous limestone is classified as chert, therefore, the assemblage is dominated by chert (`r raw_material_tbl$Proportion[2]`%) followed by limestone (`r raw_material_tbl$Proportion[3]`%) and  basalt, sandstone and quartz  were only occasionally used and constitute % and % of the assemblage respectively. Although the chert selected varies slightly from color to texture, sub-classification is not conducted due to the consistence of their physical properties which are homogeneous without fracture, joint and constant hardness. Table? Shows the different types of stone artefact that chert and limestone were employed.  `r percentage_of_chert_tools` % chert flakes were retouched into stone tools indicating a high efficient exploit of this raw material, although it can be easily obtained nearby. In terms of retouched pieces, `r chert_ret` of them are made of chert, `r limestone_ret` of them are made from limestone. It is obvious that  hominins  intended to selected chert as optimal raw material to manufacture  stone tools. 


				
```{r}
kable(raw_material_tbl)
```

The raw material source are mostly from local area that no further than 10km based on Leng and Li's investigation indicating the ability of local raw material guides the selectivity of kanppers . One possible chert source, located about 4 km (straight distence) is called Jinyan hill, where chert nodules are exposed on surface (Leng, 2001).For limestone and volcanic rocks like basalt and quartz are all from local mountain, river bed and exposed layers. The majority of raw material are accessable within 6 km (Li, 2009) suggesting  an relative small foraging territory. Leng also found that the natural chert, volcanic rock, and siliceous limestone nodules were generally larger than specimen from GYD. According to source investigation, ancient knappers were inclined to obtain raw material locally and traverl short distence to get access to raw material, besides, they were aware of raw material selection indicated by the preference of chert, which is easier control and has better flaking property as main knapping object. It also suggests that their foraging radius allows them to collect raw material and return to cave without overnight stop. 

## Taphonomy 

```{r eval = TRUE, taphonomy}
# how many flakes are broken?
flakes_broken <- 
flakes %>% 
  mutate(broken = if_else(grepl("brk|break|proximal", type), "broken", "not broken")) %>% 
  group_by(broken) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 0))

# how much heat treatment?
flakes_heated <- 
flakes %>% 
  mutate(heated = if_else(grepl("heat", 
                                `heat treatment/damage`), "heated", "not heated")) %>% 
  group_by(heated) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 0))

# how are the surface textures?
flakes_surf <- 
flakes %>% 
  group_by(`cortex texture`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 0))
```

Among the flakes in the assemblage, `r flakes_broken$perc[1]`% (n = `r flakes_broken$perc[2]`) are broken. Two processes are likely responsible for this high percentage: manufacturing failures during the knapping activity, and energetic taphonomic processes that have damages the artefacts after discard. The generally homogenous nature of the stone indicates that failures during knapping should be expected at a low frequency, assuming a compentent knapper. Thus, many of the breakages many be attributed to post-depositional processes such as ground surface breakage due to trampling. With just `r flakes_heated$n[1]` artefacts showing signs of heat treatment, we conclude that artefact damage due to excess heating occured at a negligible rate at GYD. 
 
## Flakes

```{r flakebasics}
flakes <- 
flakes %>% 
  mutate(mass = readr::parse_number(mass))

names(flakes)[30] <- "comment"
complete_flakes <- 
flakes %>% 
  filter(!grepl("brk|break|proximal|ret|retouch|pebble|tanged", type))
n_complete_flakes <- nrow(complete_flakes)

ret_flakes <- 
flakes %>% 
  filter(grepl("ret|retouch", type))

n_ret_flakes <- nrow(ret_flakes)
flake_length_mean <- round(mean(flakes$length, na.rm = TRUE),1) #there are thousands of flakes
flake_thick_mean <- round(mean(flakes$`Oriented thickness`, na.rm = TRUE),1)

# dorsal flake scars
# we only want flakes that have 0 or more scars, no NA values
flake_scar_numbers <- flakes$`scar number`[!is.na(flakes$`scar number`)]
dorsal_flake_scar_mean <- round(mean(flake_scar_numbers), 2)
dorsal_flake_scar_sd <- round(sd(flake_scar_numbers), 2)
# looking at hist(flake_scar_numbers) I see that most flakes have 3 or fewer scars
# so we can say
flakes_with_4_or_less_scars <- round(sum(flake_scar_numbers <= 4) / length(flake_scar_numbers) * 100, 1)
# what about the relationship between number of flake scars and artefact size?
cor_flake_scars_and_mass <- 
with(flakes, cor(`scar number`, mass, use = "pairwise.complete.obs"))


# Flake platforms
flakes_platforms <- 
flakes %>% 
filter(!grepl("NA|0.000000|42.000000|mis", platform)) %>% filter(!grepl("ret|retouch|pebble", type)) %>% 
group_by(platform) %>% 
tally() %>% 
filter(!is.na(platform)) %>% 
mutate(perc = round(n/sum(n),3) * 100) %>% 
arrange(desc(perc))

# percentage of each platform type
cortex_plat_perc <- flakes_platforms[flakes_platforms$platform == "cotex", ]$perc
plain_plat_perc <- flakes_platforms[flakes_platforms$platform == "plain", ]$perc
dihederal_plat_perc <- flakes_platforms[flakes_platforms$platform == "dihederal", ]$perc
facet_plat_perc <- flakes_platforms[flakes_platforms$platform == "facet", ]$perc

flakes_platform_shape <- 
flakes %>% 
filter(!grepl("NA", `platform shape`)) %>% 
  filter(!grepl("ret|retouch|pebble", type)) %>% 
  group_by(`platform shape`) %>% 
  tally() %>% 
  filter(!is.na(`platform shape`)) %>% 
  mutate(perc = round(n/sum(n),3) * 100) %>% 
  arrange(desc(perc))

triangle_platshp_perc <- flakes_platform_shape[flakes_platform_shape$`platform shape` == "triangle", ]$perc

fusiform_platshp_perc <- flakes_platform_shape[flakes_platform_shape$`platform shape` == "sx", ]$perc

quadrangle_platshp_perc <- flakes_platform_shape[flakes_platform_shape$`platform shape` == "sb", ]$perc

CDG_platshp_perc <- flakes_platform_shape[flakes_platform_shape$`platform shape` == "CDG", ]$perc

average_scar_number <- round(mean(flake_scar_numbers, na.rm = FALSE), 2)


sd_scar_number<-round(sd(flake_scar_numbers, na.rm = FALSE), 2)

flakes_with_4_or_less_scars <- sum(flake_scar_numbers <= 4 )/length(flake_scar_numbers)*100


# Cortex percentage

flake_cortex_percentage <- flakes$`cortex percentage`[!is.na(flakes$`cortex percentage`)]

flakes_with_10_or_less_cortex<- sum(flake_cortex_percentage <= 10 )/length(flake_cortex_percentage)*100

# scar direction

#how many flakes have same scar direction as flaking direction ( == 1)

library(purrr)
scar_direction <- as_data_frame(map_if(scar_direction, is.character, as.numeric))
flakes_same_scar_direction <- 
scar_direction %>% 
  filter(`scar1 direction` == 1 | # if this col == 1 or the next col, or the next 
         `scar2 direction` == 1 |  # | is the symbol for 'or'
         `scar3 direction` == 1 |
         `scar4 direction` == 1 |
         `scar5 direction` == 1 |
         `scar6 direction` == 1 |
         `scar7 direction` == 1 |
         `scar8 direction` == 1 |
         `scar9 direction` == 1 |
         `scar10 direction` == 1) %>% 
  nrow()


# Thickness for flakes, by platform shape

new_flakes <- flakes[flakes$`platform shape` %in% c("CDG", "triangle", "sb", "sx"), ]

new_flakes[new_flakes == "sb"] = "quadrangle"

new_flakes[new_flakes == "sx"] = "fusiform"

flakes_platform_shape_plot <- 
ggplot(new_flakes, 
       aes(`Thickness at 25% max dim`, 
           colour = `platform shape`)) +
  geom_density()

# dorsal flake cortex
flake_cortex_perc <- flakes$`cortex percentage`[!is.na(flakes$`cortex percentage`)]
flakes_with_20pc_cortex <- round(sum(flake_cortex_perc <= 20) / length(flake_cortex_perc) * 100, 1)

# directions of flake scars

```



```{r, thicknessplot, fig.cap="Distribution of flake thickness at three points across the flake"}

flakes_L <-  
  mutate(flakes, L = ifelse(grepl("leva", type), "L", "N"))


# explore variation in thickness in these groups
line_weight <- 1
library(ggplot2)
thick_plot <- ggplot(flakes_L) +
  geom_density(aes(`Thickness at 25% max dim`), 
               colour = "red", 
               alpha = 0.3,
               size = line_weight) +
  geom_density(aes(`Thickness at 50% max dim`), 
               colour = "green", 
               alpha = 0.3,
               size = line_weight) +
  geom_density(aes(`Thickness at 75% max dim`), 
               colour = "blue", 
               alpha = 0.3, 
               size = line_weight) +
  xlab("Thickness (mm)") +
  theme_minimal() +
  ggtitle("Distribution of flake thickness")

# draw plot
# thick_plot

```

```{r flake_platform}
# the average thickness of platform 
average_platform_thickness <- round(mean(flakes$`platform thickness`, na.rm = TRUE),2)
# the average width of platform
average_platform_width <- round(mean(flakes$`platform width`, na.rm = TRUE),2)
```


We found `r nrow(flakes)` flake pieces including complete flake (`r n_complete_flakes`), retouched flake(`r n_ret_flakes`),  flake breaks(`r n_complete_flakes`),  and retouched flake breaks(`r n_complete_flakes`),. The average maximum length of the flakes pieces is `r flake_length_mean` mm, the average thickness is`r flake_thick_mean` mm. These figures suggest that the flake from GYD are thin, indicating  the ability of knapping control.  There are `r sum(flakes_platforms$n)` flakes or broken flake that have distinguishable platforms, that  can be divided into cortex (`r cortex_plat_perc` %), plain (`r plain_plat_perc` %), facet (`r facet_plat_perc`%), dihederal (`r dihederal_plat_perc` %%) and focus. One noticeable character of the flake assemblage is the relative higher prepared platform compared with other sites in China during Middle Palaeolithic. It indicates a high exploitation capacity of raw material, probably due either to technological capacity or raw material’s flaking property.  The average thickness of platform is `r average_platform_thickness`mm; the average width of platform is `r average_platform_width`mm.  The shapes of platform include triangle (`r triangle_platshp_perc` %), fusiform (`r fusiform_platshp_perc`%), quadrangle (`r quadrangle_platshp_perc`%) and CDG (`r CDG_platshp_perc`%) and with a small account of trapezoid ，rectangle and irregular. 

In order to explore the possible relationship between platform shape with flake thickness, we compared the platform shapes with thickness at 50 max dim. Fig? shows that thickness of flakes which have CDG platform shape is more concentrated around 10-15mm. Flakes with triangle platform shape is the thickest around 20mm. Fig? shows the relationship between platform shapes and flake dimension.   % of flakes dorsal side is partially covered with cortex. Most of The cortex is limited ranging from 5 to 10 percentage.  The average scar number is `r average_scar_number` while the standard deviation is `r sd_scar_number`. Flakes with 3 dorsal scars are the largest proportion.`r round(flakes_with_4_or_less_scars,0)`% flakes have scar number less than 4. It suggests that before hominins brought knapping products into the cave, they knapped the blank outside of the cave therefore the flakes are on the late stage of knapping and with less cortex. The directions of scars of 356 flakes are recorded.  We divided the directions into 8 sections. Among them, `r flakes_same_scar_direction` flakes have dorsal scars that with the same directions of the flake, following with opposite direction(%). We also found a number of centripetal scars (%). Figure \@ref(fig:thicknessplot) shows the thickness distribution at 25%. 50% and 75%.From the chart, we can infer that the thickness at 25% is the thinnest place and thickness at 50% and 75% shares the same max dimension. It indicates that the knappers have a good control over thickness that can make the thickness under a particular thickness range. Since the max points of thickness of these three places are all around 12mm in GYD, it is reasonable to conclude that the form flakes of GYD is well controlled and relative flat.  

```{r eval= FALSE}
# this is experimental... perhaps not useful yet

# choose variables indicative of reduction pathways, based on http://link.springer.com.sci-hub.cc/article/10.1007/s10816-015-9255-x
flakes_dissim <- 
flakes %>% 
  filter(`cortex percentage` < 20) %>% 
  mutate(idx_of_conv = `Thickness at 50% max dim`/`Thickness at 75% max dim`,
         idx_of_flat = `Width at 50% max dim`/`Thickness at 50% max dim`,
         idx_of_elon = length/`Oriented width`) %>% 
  select(mass, 
         `scar number`, 
         idx_of_elon, 
         `platform thickness`,
         `Thickness at 75% max dim`,
         idx_of_conv,
         idx_of_flat,
         idx_of_elon) %>% 
  filter(complete.cases(.))

# Trying Scerri's Fig 11... according to her email reply
library(cluster)
daisy_mat <- as.matrix(daisy(flakes_dissim, metric="gower"))
daisy_mat_mds <- as_data_frame(cmdscale(daisy_mat)) # generates MDS of the dissimilarity matrix

# plot the dissimilarity, with some metric variables to show their effect
daisy_mat_mds
ggplot(daisy_mat_mds,
       aes(V1,
           V2)) +
  geom_point(aes(size = flakes_dissim$mass,
                 colour = flakes_dissim$idx_of_elon))
# important:  `platform width`, `platform thickness`, `Thickness at 75% max dim`, idx_of_flat, idx_of_elon

# how many clusters are in there?
library(NbClust)
nb <- NbClust(flakes_dissim, 
        min.nc=2, max.nc=15, method = "kmeans", 
        index = "alllong", alphaBeale = 0.1)
hist(nb$Best.nc[1,], breaks = max(na.omit(nb$Best.nc[1,]))) #  3
# what are the distinctive attributes of these clusters?
n_clust <- 3
flakes_dissim$cluster <- nb$Best.partition

ggplot(flakes_dissim,
       aes(mass,
           `platform thickness`,
           colour = factor(cluster))) +
  geom_point()

```


### Flake reduction classes



```{r corebasics}

# number of platforms on cores
cores_platform_numbers <- 
  cores %>% 
  select(platform) %>% 
  group_by(platform) %>% 
  tally() %>% 
  filter(!is.na(platform)) %>% 
  mutate(perc = round(n / sum(n) * 100, 1))

single_platform <- cores_platform_numbers$perc[cores_platform_numbers$platform == 1]
# raw materials of cores
cores %>% 
  select(material) %>% 
  group_by(material) %>% 
  tally() %>% 
   mutate(perc = round(n / sum(n) * 100, 1))
# cores shapes
cores %>% 
  select(`core geometry`) %>% 
  group_by(`core geometry`) %>% 
  tally() %>% 
   mutate(perc = round(n / sum(n) * 100, 1))
# core types 
core_types <- cores %>% 
  select(`type`) %>% 
  group_by(`type`) %>% 
  tally() %>% 
   mutate(perc = round(n / sum(n) * 100, 1))
core_type_single <- core_types %>% 
  filter(type == "single") %>% 
  .$perc

average_max_dimension <- mean(cores$`max dimension`, na.rm = TRUE)
average_mass <- mean(cores$mass, na.rm = TRUE)

# How many chert in cores 
percentage_chert_cores <-
  cores %>% 
  select(material) %>% 
  group_by(material) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 1)) %>% 
  filter(material == "chert") %>% 
  pull(perc)

#  percentage of each geometries of cores 
percentage_iregular_cores <- 
  cores %>%
  select(`core geometry`) %>% 
  group_by(`core geometry`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 1))  %>% 
  filter(`core geometry` == "iregular") %>% 
  pull(perc)

percentage_conic_cores <- 
  cores %>%
  select(`core geometry`) %>% 
  group_by(`core geometry`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 1))  %>% 
  filter(`core geometry` == "conic") %>% 
  pull(perc)

percentage_column_cores <- 
  cores %>%
  select(`core geometry`) %>% 
  group_by(`core geometry`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 1))  %>% 
  filter(`core geometry` == "column") %>% 
  pull(perc)
  
# different platform number of each core

cores_type_tally <-
  cores %>% 
  mutate(cores_type = ifelse(type %in% c("leva ", "leva? ", "leva?", "leva core", "leva?disc?", "pre leva?"), "leva", 
         ifelse(type %in% c("blade ", "blade?"), "blade", type)))
table(cores_type_tally$cores_type)

percentage_core_type_tally <- 
  cores_type_tally %>% 
  select(cores_type) %>% 
  group_by(cores_type) %>% 
  tally() %>% 
  mutate(perc = round(n/ sum(n) * 100, 1)) 


percentage_core_type_single <- 
  percentage_core_type_tally %>% 
  filter(cores_type == "single") %>% 
  pull(perc)

 percentage_core_type_double <-
   percentage_core_type_tally %>% 
  filter(cores_type == "double") %>% 
  pull(perc)
         
 percentage_core_type_multp <-
   percentage_core_type_tally %>% 
  filter(cores_type == "multp") %>% 
  pull(perc)
 
  percentage_core_type_disc <-
   percentage_core_type_tally %>% 
  filter(cores_type == "disc") %>% 
  pull(perc)
   
 # percentage of technological type of cores
  cores_type_tally2 <-
    cores_type_tally %>% 
    mutate(core_tech_type = ifelse(cores_type %in% c("single", "multp", "double"), "ordinary", cores_type))
  
  percentage_cores_type_tally2 <-
    cores_type_tally2 %>% 
    select(core_tech_type) %>% 
    group_by(core_tech_type) %>% 
    tally() %>% 
    mutate(perc = round(n / sum(n) * 100, 1))

  percentage_ordinary_cores <-
    percentage_cores_type_tally2 %>% 
    filter(core_tech_type == "ordinary") %>% 
    pull(perc)
  
  percentage_disc_cores <-
    percentage_cores_type_tally2 %>% 
    filter(core_tech_type == "disc") %>% 
    pull(perc)
  
  percentage_blade_cores <-
    percentage_cores_type_tally2 %>% 
    filter(core_tech_type == "blade") %>% 
    pull(perc)
  
  percentage_leva_cores <-
    percentage_cores_type_tally2 %>% 
    filter(core_tech_type == "leva") %>% 
    pull(perc)
  
# average core scar length
  
core_scars_length_long <-   
  core_scars_length %>% 
    gather(variable, value, -number) 


average_core_scar_length <- round(mean(core_scars_length_long$value, na.rm = TRUE) , 1)
  
# cortex percentage 

cortex_percentage<- 
  cores %>% 
  select(`cortex percentage`) %>% 
  group_by(`cortex percentage`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n) * 100, 1))


core_cortex_zero <-
  cortex_percentage %>% 
  filter(`cortex percentage` == 0) %>% 
  pull(perc)
  

# what percentage of cores have a cortex percentage less than N
N <-  30
cores_cortex_less_than_N <-
  cortex_percentage %>% 
  filter(`cortex percentage` < N) %>% 
  pull(perc) %>% 
  sum()
  
# the cortex location of cores
core_cortex_location_percentage <-
  cores %>% 
  mutate(cores_cortex_location = ifelse(`cortex location` %in% c("prox", "up"), "platform", 
        ifelse(`cortex location` == "distal", "bottom","cortex location"))) %>% 
  group_by(cores_cortex_location) %>% 
tally() %>% 
mutate(perc = round(n / sum(n) * 100, 1))

platform_cortex_core <-
  core_cortex_location_percentage %>% 
  filter(cores_cortex_location == "platform") %>% 
  pull(perc)


```

## Cores

We found `r nrow(cores)` cores in the lithic assemblage. The average max dimension is `r average_max_dimension` and with an average weight of `r average_mass` g. This dimension is slightly larger than flakes.The flaking technique of GYD is free hand percussion with hard hammer.  Chert dominates the raw material of cores(`r percentage_chert_cores`%).  There are various geometries of cores including irregular(`r percentage_iregular_cores`%), conic(`r percentage_conic_cores`%), column(`r percentage_column_cores`%) and small account of wedged and circle.  According to the number of platform, there are 3 types of cores: single platform (`r percentage_core_type_single`%), double platform (`r percentage_core_type_double`%), and multiple platform (`r percentage_core_type_multp`%). According to technological reduction, they can be classified as ordinary core (`r percentage_ordinary_cores`%), blade core (`r percentage_blade_cores`%), disc core (`r percentage_disc_cores`%) and Levallois core(`r percentage_leva_cores`%). Fig? shows the scar number of each core. The primary cores just produced 1-4 flake scars and then discarded. The cores that have more than 8 scars are occasionally shown. It suggests that the cores are not efficiently exploited. The average scar length is `r average_core_scar_length` mm which is .  Most of them are covered with zero(`r core_cortex_zero`%) or low percentage cortex which are less than `r N`% (`r cores_cortex_less_than_N`% Fig?) . The cortex location is always on platform (%) and bottom (%). Fig? shows the types of platform. The majority of platform type is plain (%) which suggests that using former scars as platform to continue flaking following flakes is the main strategy of knapping.  Remarkably, there are a notable amount of facet platforms() which presented with higher frequency on Levallois, blade and discoid cores indicating predetermined strategy was applied on more complicated techniques. The majority of cores have 1 or 2 rotation which means after knapping from one platform and then make a rotation to find a new platform to keep flaking when the original platform is no longer suitable for further knapping.  The small number of rotations reinforced the observation that most of cores in GYD are casual cores either due to the technological limitation or to the availability source of local raw materials.  

```{r retouch}
retouch_as_proportion_of_all_artefacts <- round(nrow(retouch) / total_number_of_artefacts * 100, 1)

# compare mean dimensions of retouch and plain flakes
old_names <- colnames(flakes)
flakes_clean <- data.frame(flakes[,1:28], check.names = TRUE)

flakes_clean <- 
  flakes_clean %>% 
   mutate(retouch_complete = 
            ifelse(grepl("^ret$|^ret $|^retblank$|ret bnk",
                         type), 
                   "complete_retouch", 
            ifelse(type  == "flk", 
            "complete_flake", 
            "NA")))

# join retouch to basic flakes to get retouch flake mass
flakes_clean_names <- flakes
names(flakes_clean_names) <- make.names(names(flakes_clean_names))

  
# compute the means of the numeric variables for retouch/non-retouch
flakes_clean_summary <- 
flakes_clean %>% 
  group_by(retouch_complete) %>% 
  summarise_if(is.numeric, mean, na.rm = TRUE)

basic_metrics <- c("length" , "max.dimension" , "Oriented.width" ,   "Width.at.25..max.dim" , "Width.at.50..max.dim" ,   "Width.at.75..max.dim" , "Oriented.thickness" ,   "Thickness.at.25..max.dim" ,   "Thickness.at.50..max.dim" ,   "Thickness.at.75..max.dim" , "mass" ,   "platform.width" , "platform.thickness" ,   "scar.number" , "cortex.percentage")

# look at basic metrics for complete flakes and complete retouched pieces
complete_flakes_retouch <- 
flakes_clean %>% 
  select(one_of(c("retouch_complete", basic_metrics))) %>% 
  gather(variable, value, -retouch_complete) %>% 
  filter(retouch_complete != "NA") 

# plot to see the variables by retouch vs non-retouch
plot_complete_flakes_retouch <- 
ggplot(complete_flakes_retouch,
       aes(retouch_complete,
             value)) +
    geom_boxplot()  +
    #scale_y_log10() +
  facet_wrap( ~ variable, scales = "free_y")

# stat test on basic metric variables for retouch vs non-retouch flakes. Show variables with significant difference
library(broom)
t_test_retouch_non_retouch_metrics <- 
complete_flakes_retouch %>% 
  group_by(variable) %>% 
  do(tidy(t.test(value ~ retouch_complete, data=.))) %>% 
  arrange(p.value) %>% 
  filter(p.value < 0.05)
# retouch flakes are significantly longer, and thicker at all places where we measured thickness
# average max dimesion of retouched pieces 
average_max_dim_ret <- flakes_clean %>% 
 filter(grepl("ret|retouch", type)) %>% 
  dplyr::summarise(mean(max.dimension, na.rm = TRUE))
```

```{r retouch_by_raw_material}
# just join retouch with raw material and metric data
retouch_raw_material_metrics <- 
retouch %>% 
  left_join(flakes_clean_names,
            by = "number") 

# compute tally of retouch pieces by raw material
retouch_raw_material_metrics_tally <-
 retouch_raw_material_metrics %>% 
 group_by(material) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  mutate(perc = round(n / sum(n) * 100, 1))

# general pattern for extracting single value to use in the text
retouch_perc_chert <- 
retouch_raw_material_metrics_tally %>% 
  filter(material == "chert") %>% 
  select(perc) %>% 
  collect() %>% 
  .[["perc"]]

# compare metrics by raw material
# identify the metric variables of interest
metric_variables <- 
  names(retouch_raw_material_metrics)[map_lgl(retouch_raw_material_metrics, is.numeric)][39:54]

retouch_raw_material_metrics_long <- 
retouch_raw_material_metrics %>% 
  select(material, one_of(metric_variables)) %>% 
  filter(material %in% c("chert", "limestone")) %>% 
  gather(variable, value, -material) %>% 
  filter(!is.na(value)) 

retouch_raw_material_metrics_long_plot <- 
ggplot(retouch_raw_material_metrics_long,
       aes(material,
           value)) +
  geom_boxplot() +
  scale_y_log10() +
  facet_wrap(  ~ variable,
               scales = "free_y")

retouch_raw_material_metrics_long_t_test <- 
retouch_raw_material_metrics_long %>% 
  nest(-variable) %>% 
  mutate(t_test = map(data, ~t.test(value ~  material, 
                                    data = .,
                                    na.action = na.omit))) %>% 
  mutate(t_test_tidy = map(t_test, ~tidy(.x, data = .))) %>% 
  unnest(t_test_tidy) %>% 
  filter(p.value < 0.05)
# sig diff between cortext perc and plat thick for chert vs limestone
```

```{r retouch_piece_shape, eval = FALSE}
metric_variables <- metric_variables[!is.na(metric_variables)]

# sometihng wrong with ggpairs here... 
# retouch_raw_material_metrics_plot <- 
# retouch_raw_material_metrics %>% 
#   select(material,  length, one_of(metric_variables)) %>% 
#   select(material, length, Width.at.50..max.dim, Thickness.at.50..max.dim) 
# 
# retouch_raw_material_metrics_plot_log_mass <- 
#   retouch_raw_material_metrics %>% 
#   select(material,  one_of(metric_variables)) %>% 
#   mutate(lw = length / Width.at.50..max.dim,
#          log_mass = log(mass)) %>% 
#   select(material, lw, log_mass) %>%
#   ggpairs(aes(colour = material))

# look at widths to check for circular shape or not
library(ggforce)
retouch_raw_material_metrics_big_small_shape_plot <- 
retouch_raw_material_metrics %>% 
  mutate(mass_group = ifelse(mass > 300, "big", 
                             ifelse(mass < 25, "small", NA))) %>% 
  dplyr::select(dplyr::matches("Width|material|number|mass_group")) %>% 
  select(-scar.number, 
         -`number of layers`,
         -`number of edge`, 
         -`number of burins`,
         -Oriented.width) %>% 
  
  gather(variable, value, -material, -number, -mass_group) %>% 
  filter(!is.na(mass_group)) %>% 
  ggplot(aes(variable,
             value,
             colour = mass_group)) +
  geom_boxplot() +
  geom_sina()


```

```{r retouch_blank_type}

retouch_blank_type_tally <- 
retouch_raw_material_metrics %>% 
  filter(grepl("blank|bnk|^ret$|^ret $|retouch|^ret brk$|pebble|chunk", type)) %>% 
  mutate(type3 = 
  ifelse(type %in% c("ret", "ret ", "retouch", "retouched"),
        "flake",
  ifelse(type %in% c("ret blank", "ret bnk", "ret brk","retouched blank"), 
        "broken flake", 
  ifelse(type == "pebble",
         "pebble", "chunk")))) %>% 
  group_by(type3) %>% 
  tally() %>% 
  mutate(perc = round( n / sum(n)*100, 2)) %>% 
  arrange(desc(n))

# general pattern for extracting single value to use in the text
retouch_blank_perc_flake <- 
retouch_blank_type_tally %>% 
  filter(type3 == "flake") %>% 
  select(perc) %>% 
  collect() %>% 
  .[["perc"]]

retouch_blank_perc_broken_flake <- 
retouch_blank_type_tally %>% 
  filter(type3 == "broken flake") %>% 
  pull(perc) 

```

All good up to here. 


```{r retouch_index_giur}

# looking at the GIUR data...

retouch_giur_per_section <- 
retouch %>% 
  select(grep("^number$|_t|_T", names(retouch))) %>% 
  gather(variable, value, -number) %>% 
  separate(variable, c("section", "tee"), sep = 10) %>% 
  spread(tee, value) %>% 
  mutate(t_T = t / T)  %>% 
  filter(t_T <= 1)

retouch_giur_per_artefact <- 
retouch_giur_per_section %>% 
  group_by(number) %>% 
  summarise(mean_giur = mean(t_T, na.rm = TRUE))

mean(retouch_giur_per_artefact$mean_giur)

# join metrics variables with GIUR data
retouch_giur_per_artefact_with_metrics <-
  left_join(retouch_giur_per_artefact,
            flakes_clean_names,
            by = "number")
# the average max dimension of retouched piece 
average_max_dimension_of_retouch <- round(mean(retouch_giur_per_artefact_with_metrics$max.dimension, na.rm = TRUE),2)

# what percentage of retouched pieces have a GIUR greater than N
N <-  0.5
percentage_with_giur_greater_than_N <-
  round(mean(retouch_giur_per_artefact$mean_giur > N)  * 100, 0)

# Investigate GIUR with other metric variables

# join metric variables with GIUR data
retouch_giur_metrics <- 
  left_join(retouch_giur_per_artefact, 
            flakes_clean_names, 
            by =  "number")

# visualise correlation of giur with metrics
library(GGally)
plot_retouch_giur_metrics <- 
retouch_giur_metrics %>% 
  select(-number, -type, -type2) %>% 
  select_if(is.numeric) %>% 
  ggpairs()

# do correlation test
cor.test_safe <- safely(cor.test)
retouch_giur_metrics_cor_test <- 
retouch_giur_metrics %>% 
  select(-number, -type, -type2, -site) %>% 
  select_if(is.numeric) %>% 
  gather(variable, value, -mean_giur) %>% 
  nest(-variable) %>% 
  mutate(cor_test = map(data, ~cor.test_safe(.x$mean_giur, 
                                             .x$value, 
                                             na.action = na.omit))) %>% 
  mutate(cor_test_tidy = map(cor_test, 
                             ~tidy(.x$result, 
                                   data = .))) %>% 
  unnest(cor_test_tidy)
  

# visualise correlation of giur with non-metrics
non_metrics <- names(retouch_giur_metrics)[!map_lgl(retouch_giur_metrics, is.numeric)]

library(GGally)
retouch_giur_metrics_nonmetrics_plot <- 
retouch_giur_metrics %>% 
  select(c(mean_giur, 
           one_of(non_metrics))) %>% 
  select(-number, -type, -type2, -layer, -comment) %>% 
  ggpairs()
```

```{r retouch_guir_by_zone}

retouch_giur_per_section_sides <- 
retouch_giur_per_section %>% 
  select(number, section,  t_T) %>% 
  spread(section,  t_T) %>% 
  mutate(giur_sections = 
           # one side
             ifelse(is.na(section_1_) &
                    !is.na(section_2_) &
                    is.na(section_3_) &
                    !is.na(section_4_) &
                    is.na(section_5_) &
                    !is.na(section_6_) &
                    is.na(section_7_) &
                    is.na(section_8_), 
                    "2_4_6", 
          # the other side
             ifelse(is.na(section_1_) &
                    is.na(section_2_) &
                    !is.na(section_3_) &
                    is.na(section_4_) &
                    !is.na(section_5_) &
                    is.na(section_6_) &
                    !is.na(section_7_) &
                    is.na(section_8_), 
                    "3_5_7", 
          # both sides
             ifelse(is.na(section_1_) &
                    !is.na(section_2_) &
                    !is.na(section_3_) &
                    !is.na(section_4_) &
                    !is.na(section_5_) &
                    !is.na(section_6_) &
                    !is.na(section_7_) &
                    is.na(section_8_), 
                    "2_4_6_3_5_7", 
          # one end
             ifelse(!is.na(section_1_) &
                    is.na(section_2_) &
                    is.na(section_3_) &
                    is.na(section_4_) &
                    is.na(section_5_) &
                    is.na(section_6_) &
                    is.na(section_7_) &
                    is.na(section_8_), 
                    "1",
          # the other end
             ifelse(is.na(section_1_) &
                    is.na(section_2_) &
                    is.na(section_3_) &
                    is.na(section_4_) &
                    is.na(section_5_) &
                    is.na(section_6_) &
                    is.na(section_7_) &
                    !is.na(section_8_), 
                    "8",
          # both ends
             ifelse(!is.na(section_1_) &
                    is.na(section_2_) &
                    is.na(section_3_) &
                    is.na(section_4_) &
                    is.na(section_5_) &
                    is.na(section_6_) &
                    is.na(section_7_) &
                    !is.na(section_8_), 
                    "1_8",
                    NA))))))) %>% 
  filter(!is.na(giur_sections)) %>% 
  mutate(mean_giur = rowMeans(select(., starts_with("section_")), na.rm = TRUE))

# which group has the highest GIUR?
retouch_giur_per_section_sides_by_group <- 
retouch_giur_per_section_sides %>% 
  group_by(giur_sections) %>% 
  summarise(mean_group_giur = round(mean(mean_giur),2),
            n = n()) %>% 
  mutate(perc = round(n/sum(n) * 100,1)) %>% 
  arrange(desc(mean_group_giur))
# the end scrapers are the most numerous and have the highest giur

# plot it
retouch_giur_per_section_sides_plot <- 
ggplot(retouch_giur_per_section_sides,
       aes(reorder(giur_sections, mean_giur),
           mean_giur)) +
  geom_boxplot() +
  geom_sina()

# ANOVA giur by group
retouch_giur_per_section_sides_anova <- 
retouch_giur_per_section_sides %>% 
  aov(mean_giur ~ giur_sections, data = .) %>% 
  TukeyHSD() %>% 
  tidy() %>% 
  filter(adj.p.value < 0.05)
# yes, sig diffs

# now what about size and these groups?
retouch_giur_per_section_sides_metrics_long <- 
retouch_giur_per_section_sides %>% 
  left_join(retouch_giur_metrics) %>% 
  select(giur_sections,  one_of(metric_variables)) %>% 
  gather(variable, value, -giur_sections) %>% 
  mutate(value = ifelse(variable == "mass", log(value), value))


retouch_giur_per_section_sides_metrics_long_plot <- 
ggplot(retouch_giur_per_section_sides_metrics_long,
       aes(giur_sections,
           value)) +
  geom_boxplot() +
  geom_sina() +
  facet_wrap( ~variable, scales = "free_y")

# just look at blade-like artefacts because of ambiguity about sides and ends
retouch_giur_per_section_sides_blade_plot <- 
retouch_giur_per_section_sides %>% 
  left_join(retouch_giur_metrics) %>% 
  mutate(blade_index = length / Width.at.50..max.dim ) %>% 
  filter(blade_index >= 1.5) %>% 
  select(giur_sections,  one_of(metric_variables)) %>% 
  gather(variable, value, -giur_sections) %>% 
  mutate(value = ifelse(variable == "mass", log(value), value)) %>% 
  ggplot(.,
       aes(giur_sections,
           value)) +
  geom_boxplot() +
  geom_sina() +
  facet_wrap( ~variable, scales = "free_y")
  


```

```{r retouch_ii}

retouch_ii_per_section <- 
retouch %>% 
  select(grep("^number$|_II", names(retouch))) %>% 
  gather(variable, value, -number) %>% 
  mutate(value = as.numeric(ifelse(is.na(value), 0, value)))
 

retouch_ii_per_artefact <- 
retouch_ii_per_section %>% 
  group_by(number) %>% 
  summarise(mean_ii = mean(value, na.rm = TRUE))

mean(retouch_ii_per_artefact$mean_ii)

# what percentage of retouched pieces have a II less than N
N <-  0.2
percentage_with_ii_greater_than_N <-
  round(mean(retouch_ii_per_artefact$mean_ii < N)  * 100, 0)

# histogram
# hist(retouch_ii_per_artefact$mean_ii)

# Investigate II with other metric variables

# join metric variables with ii data
retouch_ii_metrics <- 
  left_join(retouch_ii_per_artefact, 
            flakes_clean_names, 
            by =  "number")

# visualise correlation of giur with metrics
library(GGally)
plot_retouch_ii_metrics <- 
retouch_ii_metrics %>% 
  select(-number, -type, -type2) %>% 
  select_if(is.numeric) %>% 
  ggpairs()

# do correlation test
cor.test_safe <- safely(cor.test)
retouch_ii_metrics_cor_test <- 
retouch_ii_metrics %>% 
  select(-number, -type, -type2, -site) %>% 
  select_if(is.numeric) %>% 
  gather(variable, value, -mean_ii) %>% 
  nest(-variable) %>% 
  mutate(cor_test = map(data, ~cor.test_safe(.x$mean_ii, 
                                             .x$value, 
                                             na.action = na.omit))) %>% 
  mutate(cor_test_tidy = map(cor_test, 
                             ~tidy(.x$result, 
                                   data = .))) %>% 
  unnest(cor_test_tidy)
  

# visualise correlation of giur with non-metrics
non_metrics <- names(retouch_ii_metrics)[!map_lgl(retouch_ii_metrics, is.numeric)]

library(GGally)
retouch_ii_metrics_nonmetrics_plot <- 
retouch_ii_metrics %>% 
  select(c(mean_ii, 
           one_of(non_metrics))) %>% 
  select(-number, -type, -type2, -layer, -comment) %>% 
  ggpairs()

# Consider II for each zone compare the frequency of 1s vs 0.5s for the II
```

```{r retouch_type2}

retouch_type2_tally <- 
retouch_raw_material_metrics %>% 
  group_by(type2) %>% 
  tally() %>% 
  mutate(perc = round( n / sum(n)*100, 2)) %>% 
  arrange(desc(n))

# general pattern for extracting single value to use in the text
retouch_type2_perc_scp <- 
retouch_type2_tally %>% 
  filter(type2 == "scp") %>% 
  pull(perc) %>% 
  round(1)

retouch_type2_perc_dent <- 
retouch_type2_tally %>% 
  filter(type2 == "dent") %>% 
  pull(perc) %>% 
  round(1)

retouch_type2_perc_notc <- 
retouch_type2_tally %>% 
  filter(type2 == "notch") %>% 
  pull(perc) %>% 
  round(1)


# look at metrics by type2

plot_retouch_type2_basic_metrics <- 
retouch_raw_material_metrics %>% 
  filter(type2 %in% c("scp", "dent", "notch", "borer,scp")) %>% 
  select(one_of(c("type2", basic_metrics))) %>% 
  gather(variable, value, -type2) %>% 
  ggplot(aes(type2,
             value)) +
    geom_boxplot() +
  facet_wrap( ~ variable, scales = "free_y")


# ANOVA to test for statistical difference
anova_on_type2_and_metrics <- 
retouch_raw_material_metrics %>% 
   filter(type2 %in% c("scp", "dent", "notch", "borer,scp")) %>% 
  select(one_of(c("type2", basic_metrics))) %>% 
  gather(variable, value, -type2) %>% 
  nest(-variable) %>% 
  mutate(anova = map(data, ~aov(value ~ type2, data = .)))

# extract p-values and find the variable with significant different
anova_on_type2_and_metrics_pvalues <- 
anova_on_type2_and_metrics %>%
  mutate(model = map(anova, ~tidy(.x, data = .))) %>% 
  unnest(model) %>% 
  filter(term != "Residuals") %>% 
  filter( p.value <= 0.05)

anova_on_typ2_and_metrics_tukeyhsd <- 
anova_on_type2_and_metrics %>% 
  filter(variable %in% anova_on_type2_and_metrics_pvalues$variable) %>% 
  mutate(tukeyhsd = map(anova, 
                        ~tidy(TukeyHSD(.x, 
                                       data = ., 
                                       ordered = TRUE)))) %>% 
  unnest(tukeyhsd)  %>% 
  filter(adj.p.value <= 0.05)

# giur by type2
library(ggforce)
retouch_giur_metrics_plot <- 
retouch_giur_metrics %>% 
  filter(type2 %in% c("scp", "dent", "notch", "borer,scp")) %>% 
  select(type2, mean_giur) %>% 
  ggplot(aes(type2,
             mean_giur)) +
  geom_boxplot() #+ 
  geom_sina(alpha = 0.4)
  

```

```{r retouch_curvature}
retouch_raw_material_metrics <-
retouch_raw_material_metrics %>% 
  mutate(curvature = log(`retouch_depth (for curvature)`/ `retouch_diameter (for curvature)`))

# what percentage of retouched pieces have a curvature less than N
N <-  0.3
percentage_with_curv_greater_than_N <-
  round(mean(retouch_raw_material_metrics$curvature < N, na.rm = TRUE)  * 100, 0)

# histogram
# hist(retouch_raw_material_metrics$curvature)
 

# Investigate curvature with other metric variables
# join metric variables with curvature data
retouch_curvature_per_artefact <- 
   retouch_raw_material_metrics %>% 
   select(number, curvature)

retouch_curvature_metrics <- 
  left_join(retouch_curvature_per_artefact, 
            flakes_clean_names, 
            by =  "number") %>% 
  left_join(retouch_giur_metrics) %>% 
  left_join(retouch_ii_metrics) 

# visualise correlation of curvature with metrics
library(GGally)
plot_retouch_curvature_metrics <- 
retouch_curvature_metrics %>% 
  select(-number, -type, -type2) %>% 
  select_if(is.numeric) %>% 
  ggpairs()

# do correlation test
cor.test_safe <- safely(cor.test)
retouch_curvature_metrics_cor_test <- 
retouch_curvature_metrics %>% 
  select(-number, -type, -type2, -site) %>% 
  select_if(is.numeric) %>% 
  gather(variable, value, -curvature) %>% 
  nest(-variable) %>% 
  mutate(cor_test = map(data, ~cor.test_safe(.x$curvature, 
                                             .x$value, 
                                             na.action = na.omit))) %>% 
  mutate(cor_test_tidy = map(cor_test, 
                             ~tidy(.x$result, 
                                   data = .))) %>% 
  unnest(cor_test_tidy) %>% 
  arrange(p.value)
  

# visualise correlation of curvature with non-metrics
non_metrics <- names(retouch_curvature_metrics)[!map_lgl(retouch_curvature_metrics, is.numeric)]

library(GGally)
retouch_curvature_metrics_nonmetrics_plot <- 
retouch_curvature_metrics %>% 
  select(c(curvature, 
           one_of(non_metrics))) %>% 
  select(-number, -type, -type2, -layer, -comment) %>% 
  ggpairs()

```

## Retouched pieces

A total of `r nrow(retouch)` retouched pieces were found in the assemblage, accounting for `r retouch_as_proportion_of_all_artefacts`% of lithic assemblage. The average max dimension is `r average_max_dimension_of_retouch`mm. Compared with unretouched flakes, retouched pieces are generally larger, with retouched pieces having greater length, max dimension, width and thickness. This indicates that after flake production, the knappers prefer to choose bigger flakes or flake fragments to retouch, especially, longer and thicker ones. In terms of raw materials, we compared all variables between stone artefacts made of chert and limestone, the difference between them are minor except for higher cortex percentages and platform thickness among limestone artefacts. Retouched pieces are primarily made on broken flakes (`r retouch_blank_perc_broken_flake`%), flakes (`r retouch_blank_perc_flake`%), and a small number of them are made on either chunks or pebbles. Side scrapers dominate the typological classification of retouched pieces (`r retouch_type2_perc_scp`%), followed by denticulates (`r retouch_type2_perc_dent`%) and notched pieces (`r retouch_type2_perc_notc`%).



```{r retouch_edge_shape}
# edge shape, check to see that number of edge shapes matches 
# count of edge shapes
retouch$`edge shape` <- gsub(" ", "", retouch$`edge shape`) # 1101
number_of_edge_shapes <- # 1101 items
map(retouch$`edge shape`, ~unlist(strsplit(., ",|\\."))) %>% 
  map_int(., length)

edge_checking <- data_frame(count_of_edges = retouch$`number of edge`,
           number_of_edge_shapes) # 1101 rows

edge_checking$diff <- with(edge_checking, count_of_edges - number_of_edge_shapes) # 1101
edge_checking$diffl <- ifelse(edge_checking$diff == 0, TRUE, FALSE) # 1101


# only get the retouched artefacts where the count of edges matches the number of edge types
retouch_edge_shapes <- retouch[ edge_checking$diffl, ] # 783 rows

# retouch_edge_shapes$number <- gsub("f_", "", retouch_edge_shapes$number)
retouch_edge_shapes_metrics <- 
  left_join(retouch_edge_shapes, 
            flakes_clean_names, 
            by =  "number")
retouch_edge_shapes_metrics <- data.frame(retouch_edge_shapes_metrics, check.names = TRUE)

# plot distribution of edge numbers
retouch_edge_numbers_histogram <- 
ggplot(retouch_edge_shapes_metrics,
       aes(number.of.edge)) +
  geom_histogram()

# tally of edge numbers
retouch_edge_shapes_metrics_tally <- 
  retouch_edge_shapes_metrics %>% 
  group_by(number.of.edge) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n), 3) * 100)

retouch_edge_shapes_metrics_tally_1_edge <- 
retouch_edge_shapes_metrics_tally %>% 
  filter(number.of.edge == 1) %>% 
  pull(perc)

# edge layers
retouch_edge_layer_tally <- 
  retouch %>% 
  group_by(`number of layers`) %>% 
  tally() %>% 
  mutate(perc = round(n / sum(n), 3) * 100)

retouch_edge_layer_tally_1_layer <- 
retouch_edge_layer_tally %>% 
  filter(`number of layers` == 1) %>% 
  pull(perc)
           

# for all artefacts with 1 retouched edge, what shape is that?
retouch_edge_shapes_tally <- 
retouch_edge_shapes %>% 
  # filter(`number of edge` == 1) %>% 
  group_by(`edge shape`) %>% 
  tally() %>% 
   mutate(perc = round(n / sum(n), 3) * 100) %>% 
  arrange(desc(n)) 

retouch_edge_shapes_tally_strt <- 
retouch_edge_shapes_tally %>% 
  filter(`edge shape` == "strt") %>% 
  pull(perc)

retouch_edge_shapes_tally_cvx <- 
retouch_edge_shapes_tally %>% 
  filter(`edge shape` == "cvx") %>% 
  pull(perc)


# investigate metrics by edge shape
retouch_edge_shapes_metrics_by_edge <- 
retouch_edge_shapes_metrics %>% 
  group_by(edge.shape) %>%
  mutate(count = n()) %>% # how many in each group?
  summarise_if(is.numeric, mean, na.rm = TRUE) %>% 
  arrange(desc(count))  # arrange from biggest group to smallest

# just look at the first five rows, and basic metrics

retouch_edge_shapes_basic_metrics_by_edge <- 
retouch_edge_shapes_metrics_by_edge[1:5, ]  %>% 
  select(one_of(c("edge.shape", basic_metrics)))

# are notches smaller than the others?
retouch_notch_others_mass <- 
retouch_edge_shapes_metrics_by_edge %>% 
  mutate(notch = grepl("notch", edge.shape)) %>% 
  ggplot(aes(notch, mass)) +
  geom_boxplot() +
  scale_y_log10() # no

# Plot these
library(tidyr)
plot_retouch_edge_type_basic_metrics <- 
retouch_edge_shapes_metrics %>% 
  filter(edge.shape %in% retouch_edge_shapes_tally$`edge shape`[1:5]) %>% 
  select(one_of(c("edge.shape", basic_metrics))) %>% 
  gather(variable, value, -edge.shape) %>% 
  ggplot(aes(edge.shape,
             value)) +
    geom_boxplot() +
  facet_wrap( ~ variable, scales = "free_y")


# seems that it's not highly patterned, but maybe mass is worth a closer look
plot_retouch_edge_type_mass <- 
retouch_edge_shapes_metrics %>% 
  filter(edge.shape %in% retouch_edge_shapes_tally$`edge shape`[1:5]) %>% 
  select(one_of(c("edge.shape", "mass"))) %>% 
  gather(variable, value, -edge.shape) %>% 
  ggplot(aes(edge.shape,
             value)) +
    geom_boxplot()  +
  scale_y_log10()
# not a lot of difference 

# ANOVA to test for statistical difference
anova_on_edge_shape_and_metrics <- 
retouch_edge_shapes_metrics %>% 
  filter(edge.shape %in% retouch_edge_shapes_tally$`edge shape`[1:5]) %>% 
  select(one_of(c("edge.shape", basic_metrics))) %>% 
  gather(variable, value, -edge.shape) %>% 
  nest(-variable) %>% 
  mutate(anova = map(data, ~aov(value ~ edge.shape, data = .)))

# extract p-values and find the variable with significant different
anova_on_edge_shape_and_metrics_pvalues <- 
anova_on_edge_shape_and_metrics %>%
  mutate(model = map(anova, ~tidy(.x, data = .))) %>% 
  unnest(model) %>% 
  filter(term != "Residuals") %>% 
  filter( p.value <= 0.05)

anova_on_edge_shape_and_metrics_tukeyhsd <- 
anova_on_edge_shape_and_metrics %>% 
  filter(variable %in% anova_on_edge_shape_and_metrics_pvalues$variable) %>% 
  mutate(tukeyhsd = map(anova, 
                        ~tidy(TukeyHSD(.x, 
                                       data = ., 
                                       ordered = TRUE)))) %>% 
  unnest(tukeyhsd)  %>% 
  filter(adj.p.value <= 0.05)
```

Most retouched pieces (`r retouch_edge_shapes_metrics_tally_1_edge`%) have just one retouched edge, and about one third have two edges. Retouch was generally observed as a single layer of flake scars (`r `number of layers`%). The edge shapes are mostly straight (`r retouch_edge_shapes_tally_strt`%) and convex (`r retouch_edge_shapes_tally_cvx`%), with smaller amounts of concave, denticulate, end, notch, borers, and various combinations of these features. 

```{r retouch_edge_angle}
# average edge angle
edge_angle_long <- 
edge_angle %>% 
  gather(variable, value, -number) %>% 
  rename(edge_angle_mm = value) %>% 
  mutate(edge_angle_deg = 2 * (atan(0.5 * (edge_angle_mm/3) ) ) / (pi/180))

edge_angle_long_mean <- 
edge_angle_long %>% 
  group_by(number) %>% 
  summarise(mean_edge_angle_per_artefact = mean(edge_angle_deg, na.rm = TRUE ))

# hist(edge_angle_long_mean$mean_edge_angle_per_artefact)

mean_edge_angle_overall <- round(mean(edge_angle_long_mean$mean_edge_angle_per_artefact, na.rm = TRUE),0)

# what percentage of artefacts pieces have an edge angle greater than N
N <-  65
percentage_with_edge_angle_greater_than_N <-
  round(mean(edge_angle_long_mean$mean_edge_angle_per_artefact > N, na.rm = TRUE)  * 100, 0)

edge_angle_metrics <- 
edge_angle_long %>% 
  mutate(number = paste0("f_", number)) %>% 
  left_join(retouch_curvature_metrics)

# Do levallois pieces have higher angles? Eren says Yes, "These differences were evident both in terms of relatively higher (i.e., more obtuse) edge angles than debitage flakes and in being significantly less variable around their higher mean edge angles compared to debitage flakes."

library(ggforce)
edge_angle_metrics_lev <- 
edge_angle_metrics %>% 
  filter(type %in% c("leva", "leva ","leva flake ", "ret")) %>% 
  mutate(type = ifelse(type %in% c("leva", "leva ","leva flake "), 
                       "leva", type))

library(ggforce)
edge_angle_metrics_lev_plot <- 
ggplot(edge_angle_metrics_lev,
       aes(type,
           edge_angle_deg)) +
  geom_boxplot() +
  geom_sina(maxwidth = 1)

# our levallois pieces are slightly higher... sig test?

# sig diff between leval and non-L edge angles?
edge_angle_metrics_lev_t_test <- 
  edge_angle_metrics_lev %>%
  t.test(edge_angle_deg ~ type, data = .)  %>% 
  tidy()

# not significant, not like Eren's assemblage 
  
# check for variability of edge angles for L and non-L
edge_angle_metrics_lev_var <- 
  edge_angle_metrics_lev %>% 
    group_by(number, type) %>% 
    summarise(cv = raster::cv(edge_angle_deg, na.rm = TRUE),
              sd = sd(edge_angle_deg, na.rm = TRUE)) %>% 
    filter(!is.na(cv)) 

# differences between each angle measurent across the artefact, or Eren's 'organised' vs 'disorganised'
edge_angle_organisation <- 
edge_angle %>% 
   mutate(number = paste0("f_", number)) %>% 
  left_join(retouch_curvature_metrics) %>% 
    filter(type %in% c("leva", "leva ","leva flake ", "ret")) %>% 
  mutate(type = ifelse(type %in% c("leva", "leva ","leva flake "), 
                       "leva", type)) %>% 

  mutate(s1_s2 = abs(section_1_angle - section_2_angle),
         s2_s4 = abs(section_2_angle - section_4_angle),
         s4_s6 = abs(section_4_angle - section_6_angle),
         s6_s8 = abs(section_6_angle - section_8_angle),
         s8_s7 = abs(section_8_angle - section_7_angle),
         s7_s5 = abs(section_7_angle - section_5_angle),
         s5_s3 = abs(section_5_angle - section_3_angle),
         s3_s1 = abs(section_3_angle - section_1_angle)) %>% 
  rowwise() %>% 
  mutate(mean_diff_between_angles_on_the_artefact = mean(c(s1_s2,
                                                           s2_s4,
                                                           s4_s6,
                                                           s6_s8,
                                                           s8_s7,
                                                           s7_s5,
                                                           s5_s3,
                                                           s3_s1),
                                                           na.rm = TRUE)) 

# is there a difference in organisation of edge angle between Levallois and non-L
edge_angle_organisation_plot <- 
ggplot(edge_angle_organisation,
       aes(type,
           mean_diff_between_angles_on_the_artefact)) +
  geom_boxplot() +
  geom_sina()


edge_angle_metrics_lev_var_plot <- 
ggplot(edge_angle_metrics_lev_var,
       aes(type,
           cv)) +
  geom_boxplot() +
  geom_sina(maxwidth = 1)

  
# ANOVA to test for statistical difference between edge angles and artefact type
anova_on_edge_angle_metrics_lev_aov <- 
edge_angle_metrics_lev %>% 
  select(edge_angle_deg, type) %>% 
  aov(edge_angle_deg ~ type, data = .) %>% 
  tidy()

# cor test for relationship between edge angles and other numerics
# extract p-values and find the variable with significant different
edge_angle_metrics_lev_cor_test <- 
edge_angle_metrics_lev %>% 
  select(-number, -type, -type2, -site) %>% 
  select_if(is.numeric) %>% 
  gather(variable, value, -edge_angle_deg) %>% 
  nest(-variable) %>% 
  mutate(cor_test = map(data, ~cor.test_safe(.x$edge_angle_deg, 
                                             .x$value, 
                                             na.action = na.omit))) %>% 
  mutate(cor_test_tidy = map(cor_test, 
                             ~tidy(.x$result, 
                                   data = .))) %>% 
  unnest(cor_test_tidy) %>% 
  filter( p.value < 0.05)

edge_angle_metrics_lev_metric_cor <- 
edge_angle_metrics_lev %>% 
  select(-number, -type, -type2, -site) %>% 
  select_if(is.numeric) %>% 
  gather(variable, value, -edge_angle_deg) %>% 
  ggplot(., 
         aes(edge_angle_deg, 
             value)) +
  geom_point() +
  facet_wrap( ~ variable, 
              scales = "free_y")

# edge angle by artefact type
edge_angle_by_artefact_type <- 
edge_angle_metrics_lev %>% 
  filter(type2 %in% c("scp", "dent", "notch", "borer,scp")) %>% 
ggplot(., 
       aes(type2, 
           edge_angle_deg)) + 
  geom_boxplot()

# ANOVA for edge angle by artefact type. 
edge_angle_metrics_lev_aov <- 
edge_angle_metrics_lev %>% 
  filter(type2 %in% c("scp", "dent", "notch", "borer,scp")) %>% 
  aov(edge_angle_deg ~ type2, data = .) %>% 
  tidy()

df <- paste0(edge_angle_metrics_lev_aov$df[1], ", ", edge_angle_metrics_lev_aov$df[2])
```

We calculated the edge angle by measuring the width at the 3 mm depth of the edge, following Eren and Lycett (2016). The average angle of each edge is `r mean_edge_angle_overall` degrees. Notably, there is a high proportion of the assemblage with relatively high edge angles, `percentage_with_edge_angle_greater_than_N`% of artefacts have average edge anlges greater than `r N`, which is not common in other sites (citation needed!). This feature may be explained as a result of the available raw material nodules which had a slab or tablet-like shape, leading to  steep edge angles in the flakes peices that are close to the edge angles on the unworked nodules. Edge angles are similar in mean and variation across the most abundant different types of retouched artefacts (F(`r df`) = `r round(edge_angle_metrics_lev_aov$statistic,2)[1]`, p = `r  round(edge_angle_metrics_lev_aov$p.value,2)[1]`). 


### Indices

We use two methods to summarise the invasiveness and intensity of retouching: Kuhn's (1990) 'Geometric Index of Unifacial Reduction (GIUR)', and Clarkson's (2002) 'Index of Invasiveness'. In this assemblage, if a flake is retouched, the retouch tends to be extensive. This is suggested by the relatively highg GIUR values. We found that `r percentage_with_giur_greater_than_N`% of retouched artefacts have a GIUR greater than `r N`. However, there are no strong correlations between GIUR values and other variables such as length, width and thickness, suggesting that retouch intensity is largely independant of other technological attriutes. From our observations... 

We also measured the angle of each retouched edge. For notch pieces(n=91), we found that most notches only have one notch end on each retouched piece and the average depth and length is xx and xx. The location of retouching is mainly on one side which defined as longer geometric side of the piece.  Except retouching with hard hammer percussing, pressing is also likely utilized demonstrated by flat and enlonged retouching scars. One remarkable feature of the retouching is demonstrated by a strong moustrian style with regular and continues retouching scars producing even edges on a large number of tools

## Levallois 

We distinguished 70 stone artifacts that are Levallois like products including 11 cores, 22 flakes, 4 points and 33 tools made on levallois flakes. The average dimension of levallois products is xxx which is smaller (or larger) than ordinary products. The platform shapes of levallois flakes are various ranging from triangle, quadrangle, fusiformis to chapeau de gendarme(CDG). For flakes, we measured the thickness at 25%, 50%, 70% max dimension and compared them with ordinary flakes found that levallois flakes are relatively more flat. This found is consistent with the theory that ... The scar number is also relatively more than ordinary flakes, the direction of which is mostly centripetal. The platform of Levallois flakes and flake fragments are mainly plain(n=22), followed by facet(n=12) and the platform shapes are mainly CDG(n=15), followed by triangle(n=8) and quadrangle(n=6). The dorsal scar patterns can be divided into two main types: centripetal pattern which is covered by flake scars that are distributed centripetally and big scar pattern which is characterized by a giant scar from the same direction covering the most part of the dorsal area with proximal parts of centripetal scars on the margin(Fig?). Generally, the later pattern ends up with a relative flatter body and more possibilities of CDG platform shape. The configuration of levallois cores volumes were maintained through the detachment of predetermining Levallois and trimming striking platform flakes. The average max dimension is 82mm. Most of their platforms are facet(n=5). These cores are classified as Levallois is accorded to several key technical criteria (Boeda,1994) : 1) the flaking surface is maintained through predetermined flake scars that is arranged centripetally; 2) the fracture plane of detachment are almost parallel to the plane of intersection of the upper and lower surface; 3) and the two surface are hierarchicaly related. More than half of these cores retain a portion of cortex on the surface. The average scar number of each core is 4.5, and the average length of these scars is 40mm. 12 discoid cores are also found in the assemblage which are separated with Levallois cores. Although most of discoid cores also share similar features with Levallois, based on the 5 criteria definited by Boeda, it is more reasonable to classify them to discoid. 

# Discussion

1) Comparing with other sites in south China, Guanyindong is featured by the appearance of Levallois technique.Why do you think Gyd has levallois? Previous results from other sites in South China suggest that they have no levallois techinique (give examples and discussions)

2) In the lithic assemblage, we found 59 Levallois flakes, 11 Levallois cores, with distinguishable characters from Europe and Africa(less proportion, relative more proto morphology). What are the main difference between Gyd and other sites. What is the implication of such difference. Are there any difference in the Levallois techniques in Europe and Africa or other Asia sites?

3) Provide detailed discussion on the Demographic model, and explain the reason why Levallois technique in Southeast Asia is different from western. China and Southeast Asia is geographically distant from East Africa where Levallois technique is originated, as hominids dispersal from western to eastern, progressively smaller population, drastic changes of environment have made an inevitable influence on the style of Levallois technique. 

4) Drawbacks (assumptions) of the model. Other possible explanation you can offer.



# Conclusion
